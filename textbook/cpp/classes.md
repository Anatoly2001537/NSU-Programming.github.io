---
title: Классы
---

# {{ page.title }}

## Парадигмы программирования

В ходе развития языков программирования и подходов к созданию программ были сформулированы различные [парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F). Парадигма - это совокупность идей и понятий, определяющих стиль написания программ. Язык C++ позволяет использовать различные парадигмы, самые распространенные из которых - [структурное](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), [объектно-ориентированное](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) и [обобщенное программирование](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). Чаще всего используется комбинация идей из разных парадигм, так, лямбда-выражения, которые мы уже освоили, пришли из [функционального программирования](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

Язык C++ создавался как язык с полной поддержкой объектно-ориентированной парадигмы (ООП) программирования. Всесторонее обсуждение концепции объектно-ориентированного подхода не является сейчас нашей целью, однако некоторые базовые принципы необходимо рассмотреть.

ООП рассматривает программу как множество взаимодействыющих *объектов*. Объект обладает некоторым состоянием и предоставляет определенный *интерфейс*, с помощью которого с ним можно взаимодействовать. Объекты в общем случае являются экземплярами различных классов. Мы знакомы уже со многими классами, хотя раньше мы их так не называли. Все типы стандартной библиотеки, кроме базовых, являются классами. Например, класс `string`. Переменная типа `string` является экземпляром класса. Набор символов строки определяет состояние экземпляра `string`, а взаимодействие с набором символов возможно только посредством методов, определенных в классе `string`. Идея связи данных и способов работы с ними в объекте называется *инкапсуляцией* и является фундаментальной в ООП.

Инкапсуляция позволяет уменьшить зависимость различных частей программы друг от друга. Представим, что разработчик осознал, что использовал не оптимальную структуру данных, либо не самый быстрый алгоритм. Если он устранит недостатки в своем типе данных (классе), сохранив интерфейс, то другие части программы не потребуется изменять. В больших проектах слабая зависимость разных частей кода является абсолютно необходимой.

Теперь мы готовы перейти к обсуждения средств языка C++, реализующих идеи инкапсуляции.

## Классы C++: начало

Минимальный класс выглядит так:

```cpp
class LorentzVector {};

LorentzVector lv;
```

Судя по названию, мы решили реализовать класс четырех-векторов. Мы уже можем создавать объекты нашего класса, однако в остальном наш класс пока бесполезен.

Класс может содержать *поля* и *методы*. Поля класса могут быть объектами любого типа, набор и содержание полей определяют состояние объекта. Методы - это функции, связанные с классом. Рассмотрим на примере:

```cpp
class LorentzVector {
    // по умолчению private
    double t_;  // поле: временная компонента
    double x_;  // поле: пространственная компонента

 public:
    // константный публичный метод
    double t() const {
        return t_;
    }
    // константный публичный метод
    double x() const {
        return x_;
    }
    // публичный метод
    double& t() {
        return t_;
    }
    // публичный метод
    double& x() {
        return x_;
    }
};
```

Мы добавили в класс поля `t_` и `x_` и методы для доступа к ним. Поля и методы класса могут быть публичными или привантыми. К публичным методам и полями можно обращаться при работе с объектом класса. Приватные поля и методы доступны только методам самого класса. Ключевые слова `private` и `public` выполняют переключение на приватную ипубличную часть класса. В соответствии и идеей инкапсуляции мы поместили поля в приватную часть класса. Это позволит нам в дальнейшем изменить способ хранения данных. Например, мы могли бы определить поля так:

```cpp
class LorentzVector {
    std::array<2, double> data_;
// ...
};
```

не меняя при этом публичные методы. Следующая деталь - методы могут быть константными. Делая метод константным, мы обещаем, что при вызове этого метода мы не изменим *видимое* состояние объекта. Методы чтения полей - хороший пример константных методов. Определять методы константными не обязательно, но крайне желательно. Во-первых, это значительно повышает выразительность кода, а во-вторых, позволяет использовать метод, если наш объект - константный. Например:

```cpp
LorentzVector lv1;
lv1.t_ = 1.;  // ошибка: поле t_ - приватное
lv1.t() = 1.;
lv1.x() = 0.5;

cout << "(" << lv.t() << ", " << lv.x() << ")\n";

const LorentzVector lv2;
lv2.t() == 1.;  // ошибка: вызов неконстантного метода у константного объекта
```

Обратите внимание, что мы определили методы с одинаковыми названиями, но различными *сигнатурами*. Компилятор всегда может выбрать нужный метод. Такой прием называется перегрузкой методов.

## Конструктор

При создании объекта вызывается специальный метод - конструктор, который выполняет инициализацию объекта. В нашем классе конструктор не был определен, поэтому компилятор сгенерировал его автоматически. Поля `t_` и `x_` инициализировались значениями по умолчению типа `double`. Определим конструктор для нашего класса:

```cpp
class LorentzVector {
    // ...
 public:
    // конструктор по умолчанию
    LorentzVector() {
        t_ = 0;
        x_ = 0;
    }
    // еще один конструктор
    LorentzVector(double ti, double xi) {
        t_ = ti;
        x_ = xi;
    }
}
```

Конструктор должен называться так же как класс, для него не надо указывать тип возвращаемого значения. Конструкторов может быть несколько, каждый из них должен иметь уникальную сигнатуру. Создавать объекты нашего класса теперь удобнее:

```cpp
LorentzVector lv(1, 0.5);
```

В теле конструктора можно выполнять различные действия, например, вызывать другие методы класса. Простую инициализацию полей можно выполнять элегантнее:

```cpp
class LorentzVector {
    // ...
 public:
    LorentzVector() = default;  // конструктор по умолчанию
    // еще один конструктор
    LorentzVector(double ti, double xi) : t_(ti), x_(xi) {}
}
```

Ключевое слово `default`, которое мы использовали с конструктором по умолчанию, говорит компилятору самостоятельно создать этот конструктор. В нашем случае это хорошее решение. Если бы мы определили только конструктор с параметрами, то конструктор по умолчанию не был бы создан. В конструкторе с параметрами мы использовали специальный способ инициализации полей после двоеточия. Это является рекомендуемым способом инициализации полей. Помимо краткости, эта конструкция лучше с точки зрения производительности. Дело в том, что поля объекта в любом случае инициализируются до начала исполнения инструкций в теле конструктора. Предыдущая версия конструктора, таким образом, сначала выполняла инициализацию по уполчанию, а затем присваивание необходимых значений. Новая версия конструктора избегает лишних манипуляций.

Добавим к классу метод `boosted`, возвращающий вектор с преобразованными компонентами:

```cpp
class LorentzVector {
    // ...
 public:
    // Преобразование Лоренца с фактором beta
    LorentzVector boosted(double beta) {
        double gamma = std::sqrt(1/(1-beta*beta));
        return {
            gamma * (t_ - beta * x_),
            gamma * (x_ - beta * t_)
        };
    }
    // ...
};
```

Обратите внимание, что мы вернули пару чисел в фигурных скобках. Если переданные значения соответствуют аргументам конструктора возвращаемого значения, то компилятор корректно создаст нужный объект.

## Перегрузка операторов

C++ позволяет максимально интегрировать пользовательские типы данных и сделать работу с ними похожей на работу со встроенными типами. Во многом это достигается благодаря перегрузке операторов. Нашему классу очевидно не хватает операция сложения, вычитания, умножения на число и т.д. Формально корректным решением было бы создание методов, подобных этому:

```cpp
class LorentzVector {
    // ...
 public:
    LorentzVector Add(const LorentzVector& rhs) const {
        return {t_ + rhs.t_, x_ + rhs.x_};
    }
    // ...
};
```

Гораздо удобнее, однако, для сложения векторов использовать оператор `+`. Для этого необходимо выполнить перегрузку этого оператора, т.е. определить его для нашего типа данных:

```cpp
LorentzVector operator+(const LorentzVector& lhs, const LorentzVector& rhs) {
    return {lhs.t() + rhs.t(), lhs.x() + rhs.x()};
}
```

Полный список операторов, которые можно перегрузить, смотрите в [документации](https://en.cppreference.com/w/cpp/language/operators). Если оператору необходим доступ к приватным частям класса, то его можно сделать членом класса. Другим решением является объявление оператора с помощью ключевого слова [friend](https://en.cppreference.com/w/cpp/language/friend). Выбор из разных опций является во много делом вкуса, но при принятии решения можно иметь в виду аргумент о том, что минимальное использование приватных частей класса позволяет лучше сохранять независимость разных частей кода.

Рассмотрим перегрузку операторов `<<` и `>>`, которая позволяет использовать наш класс естественным образом при работе с потоками:

```cpp
#include <iostream>

ostream& operator<<(ostream& os, const LorentzVector& lv) {
    os << "(" << lv.t() << ", " << lv.x() << ")";
    return os;
}
```

```cpp
#include <iostream>

istream& operator<<(istream& is, LorentzVector& lv) {
    is >> lv.t() >> lv.x();
    return is;
}
```

Нашим классом становится приятно пользоваться:

```cpp
LorentzVector lv1(1, 0.5);
LorentzVector lv2(0.2, -0.1);

LorentzVector lv3 = lv1 + lv2;

cout << lv1 << " + " << lv2 << " = " << lv3 << endl;
```

## Статические поля и методы

Еще одна возможность классов C++ - создание полей и методов, связанных с самим классом, а не с объектами класса. Такие поля и методы называют статическими, они определяются с помощью ключевого слова `static`. Давайте добавим к нашему классу счетчик всех созданных объектов. Для этого нам понадобится статические поле и новая логика в конструкторе:

```cpp
// файл lvec.h
class LorentzVector {
    // приватное статическое поле
    static size_t counter;

 public:
    LorentzVector(double ti, double xi) : t_(ti), x_(xi) {
        ++counter;  // увеличиваем счетчик объектов
    }
    // публичный статический метод
    static size_t objects_created() {
        return counter;
    }
    // ...
};

// файл lvec.cpp, инициализируем статическое поле
size_t LorentzVector::counter = 0;
```

Статическое поле необходимо инициализировать за пределами определения класса. Более того, чтобы иметь можность подключать наш класс в другие файлы, инициализация статического поля должна находиться в отдельном файле. Подробнее мы об этом поговорим в конце этого раздела.

## Правило пяти

Мы уже упоминали о том, что если мы не определили ни одного конструктора, компилятор попробует сгенерировать конструктор по умолчанию самостоятельно. Это не единственный специальный метод, который компилятор создает автоматически в некоторых ситуациях. Полная скрытая сигнатура нашего "пустого" класса выглядит так:

```cpp
class LorentzVector {
 public:
    // конструктор по умолчанию
    LorentzVector();
    // копирующий конструктор
    LorentzVector(const LorentzVector&);
    // перемещающий конструктор
    LorentzVector(LorentzVector&&);
    // копирующий оператор присваивания
    LorentzVector& operator=(const LorentzVector&);
    // перемещающий оператор присваивания
    LorentzVector& operator=(LorentzVector&&);
    // деструктор
    ~LorentzVector();
};
```

При выходе объекта из области видимости, у объекта вызывается деструктор.

TODO

## Организация файлов

TODO

## Резюме

В этой части мы обсудили идею инкапсуляции, одну из ключевых идей объектно-ориентированного программирования, и основные инструменты создания классов в C++:

* поля и методы
* приватная и публичная части определения классов
* перегрузка операторов
* статические поля и методы
* методы, которые генерируются компилятором
* рекомендуемая организация файлов при создании классов

Эти фундаментальные знания уже позволяют вам реализовывать сложную логику в рамках объектно-ориентированного подхода. Далее мы продолжим изучение концепций ООП и из реализацию в языке C++.

## Документация

* [https://en.cppreference.com/w/cpp/language/operators](https://en.cppreference.com/w/cpp/language/operators)
* [https://isocpp.org/wiki/faq/operator-overloading](https://isocpp.org/wiki/faq/operator-overloading)
* [https://en.cppreference.com/w/cpp/language/friend](https://en.cppreference.com/w/cpp/language/friend)
* [https://en.cppreference.com/w/cpp/language/rule_of_three](https://en.cppreference.com/w/cpp/language/rule_of_three)
