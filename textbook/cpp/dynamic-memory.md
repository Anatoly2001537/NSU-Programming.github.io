---
title: Динамическое выделение памяти
---

# {{ page.title }}

## Два вида памяти

Программе на C++ доступны два вида памяти: стек и куча (heap). Автоматические переменные базовых типов вроде

```cpp
int a;
double b;
```

хранятся на стеке. Как следует из названия, переменные в стек по схеме FILO (first in last out). Управление стеком происходит автоматически. При выходе переменной из области видимости соответствующая ей в стеке память освобождается. Поэтому нам не нужно следить за удалением автоматических переменных. Стек работает очень быстро, но имеет ограниченный размер, который обычно не превосходит нескольких мегабайт.

Второй тип памяти - куча - устроен иначе. В куче объекты можно хранить в произвольном месте, а по размеру куча чаще всего значительно больше стека. Платить за эти преимущества приходится скоростью: работа с кучей происходит значительно медленнее, чем со стеком. Кроме того, объекты из кучи не удаляются автоматически.

Куча используется в двух случаях:

* Необходимо хранить большой объект. Хранение больших объектов на стеке может привести к его переполнению (stack overflow)
* Автоматическое управление памятью в стеке не соответствует логике программы. Чаще всего такая ситуация возникает, когда созданный объект должен продолжать свое существование после выхода из блока, в котором он был создан. Ниже мы рассмотрим примеры.

Динамическое выделение памяти означает выделение памяти в куче. Способы работы с памятью в куче является предметом данного раздела.

## Ручное управление памятью

Создать объект в куче можно с помощью оператора `new`:

```cpp
int *a = new int(7);
```

Таким образом можно создать объект любого класса. Оператор `new` возвращает указатель на область памяти, в которой находится созданный объект. Использовав оператор `new`, мы становимся ответственными за удаление объекта и освобождение выделенной для него памяти. Удалить перменную `a` из кучи можно с помощью оперетора `delete`:

```cpp
delete a;
```

Вернемся к примеру из раздела про наследование, в котором мы строили модель символов в графическом текстовом редакторе. Напомним, что мы имели абстрактный базовый класс `Character` и два его наследника `Letter` и `Digit`. Допустим, что нам надо реализовать функцию, которая возвращает полиморфный список символов. Без динамического выделения нам будет сложно реализовать эту задачу. Например:

```cpp
std::list<Character*> char_producer() {
    // Тут есть проблема
    Letter l1('a');
    Letter l2('b');
    Digit d1('1');
    Digit d2('2');
    return std::list<Character*>{&l1, &l2, &d1, &d2};
}
```

Переменные `l1`, `l2`, `d1` и `d2` в функции `char_producer` созданы обычным образом. Память для них выделилась на стеке. При выходе из функции для них будут вызваны деструкторы, и память на стеке освобождена. Небольшое изменение сделает код корректным:

```cpp
std::list<Character*> char_producer() {
    auto* l1 = new Letter('a');
    auto* l2 = new Letter('b');
    auto* d1 = new Digit('1');
    auto* d2 = new Digit('2');
    return std::list<Character*>{l1, l2, d1, d2};
}
```

Теперь память для объектов выделена в куче и они продолжают существовать и после выхода из функции. Мы можем использовать эту функцию в другой функции, которая, например, выводит символы в стандартный поток вывода:

```cpp
// здесь есть проблема
void print_document() {
    auto doc = char_producer();
    for (auto item : doc) {
        cout << item;
    }
}
```

Эта функция приводит к утечке памяти. При каждом ее вызове в куче выделяется память, которая никогда не освобождается. Более аккуратная реализация выглядит так:

```cpp
void print_document() {
    auto doc = char_producer();
    for (auto item : doc) {
        cout << item;
    }
    // здесь тоже есть проблема, но ее мы обсудим позже
    for (auto item : doc) {
        delete item;
    }
}
```

Аналогично, если в конструкторе класса происходит динамическое выделение памяти (или выделение других ресурсов, таких как подключение через сокеты), то в деструкторе они должны быть освобождены. В противном случае возникнет утечка памяти.

Существует также версии оперторов `new` и `delete` для создания массивов объектов:

```cpp
int* p = new int[10];  // выделяем массив из 10 переменных типа int
delete[] p;
```

При освобождении памяти надо не использовать правильную версию оператора `delete`.

Работа с динамической памятью с помощью операторов `new` и `delete` весьма сложна, часто приводит к утечке ресурсов, источник которой трудно отследить. В современном C++ не рекомендуется использовать эти инструменты. Далее мы рассмотрим инструменты, которые делают работу с динамической памятью гораздо более простой и удобной.

## Умные указатели

Идея, с помощью которой в современнном C++ реализована работа с динамической памятью, состоит в инкапсуляции логики работы с кучей в специальный объект: `std::unique_ptr` или `std::shared_ptr`. При создании такого объекта происходит выделение памяти, а при удалении - освобождение. Например:

```cpp
#include <memory>

int main() {
    auto luptr = std::make_unique<Letter>('l');
    auto dsptr = std::make_shared<Digit>('7');
    return 0;
}
```

При выходе из функции `main` выделенная в куче память кооректно освободится автоматически. Объекты `std::unique_ptr` и `std::shared_ptr` различаются с точки зрения *владения* объектом. Уникальный указатель `std::unique_ptr` единолично владеет объектом. Это означает, что не может быть два объекта `std::unique_ptr`, указывающих на один и тот же объект, а при удалении `std::unique_ptr` из области видимости память освобождается.

```cpp
auto luptr = std::make_unique<Letter>('l');
// std::unique_ptr<Letter> luptr2 = luptr;  // ошибка, уникальное владение
auto luptr3 = std::move(luptr);  // перемещение возможно. luptr передал владение и потерял связь с объектом
```

Объект `std::shared_ptr` можно копировать, таким образом несколько объектов `std::shared_ptr` могут указывать на один и тот же объект. Освобождение памяти в куче происходит в момент, когда последний ссылающийся на эту память объект `std::shared_ptr` вышел из области видимости. Из-за необходимости подсчета ссылок `std::shared_ptr` приводит к некоторым накладным расходам, например, он занимает больше памяти, чем `std::unique_ptr`. Объекты `std::unique_ptr` в свою очередь практически не уступают в производительности простым указателям.

Важно, что умные указатели сохраняют свойство полиморфности. Это позволяет нам модифицировать функцию `char_producer` следующим образом:

```cpp
std::list<std::unique_ptr<Character>> char_producer() {
    std::list<std::unique_ptr<Character>> doc;
    doc.push_back(std::make_unique<Letter>('a'));
    doc.push_back(std::make_unique<Letter>('b'));
    doc.push_back(std::make_unique<Digit>('1'));
    doc.push_back(std::make_unique<Digit>('2'));
    return doc;
}
```

и не заботится больше о ручном освобождении ресурсов. Несмотря на некоторую громоздкость синтаксиса умные указатели значительно упрощают разработку на C++. Мы рекомендуем использовать умные указатели вместо низкоуровневых операторов `new` и `delete` для работы с динамической памятью.

## Идиома RAII

Идея умных указателей является частным случаем идиомы [RAII](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B0_%D0%B5%D1%81%D1%82%D1%8C_%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) (получение ресурса есть инициализация). Идиома RAII применима к объектам, которые владеют каким-либо ресурсом (динамической памятью, файловым дескриптором и т.п.), и состоит в том, что владение устанавливается при инициализации объекта, и прекращается при уничтожении объекта. Объекты `fstream` стандартной библиотеки также являются RAII-объектами, они закрывают связанный с ними файл, когда выходят из области видимости.

## Виртуальный деструктор

В заключение обсудим один тонкий момент, связанный с наследованием и владением ресурсами. Если работа с объектом класса-наследника происходит через указатель на объект базового класса, как это происходило в последних версиях функции `char_producer`, необходимо объявлять деструктор базового класса виртуальным. Если этого не сделать, то для всех объектов будет вызван деструктор базового класса, что может привести к неполному освобождению ресурсов и утечке памяти (строго говоря, возникает ситуация неопределенного поведения).

Необходимая модификация заключается в следующем:

```cpp
class Character {
    // ...
    virtual ~Character() = default;
};
```

Это объявление гарантирует, что при удалении объекта через указатель на `Character` будет выполнен поиск необходимого деструктора с помощью таблиц виртуальных функций.

## Резюме

В этом разделе мы обсудили основы работы с динамической памятью с C++. Рекомендуемыми инструментами работы с динамической памятью являются умные указатели `std::unique_ptr` и `std::shared_ptr`.

## Документация и ссылки

* [https://en.cppreference.com/w/cpp/memory/new/operator_new](https://en.cppreference.com/w/cpp/memory/new/operator_new)
* [https://en.cppreference.com/w/cpp/memory/new/operator_delete](https://en.cppreference.com/w/cpp/memory/new/operator_delete)
* [Идиома RAII (wikipedia)](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B0_%D0%B5%D1%81%D1%82%D1%8C_%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)