---
layout: default
title: Основы синтаксиса языка python
---

# {{ page.title }}

Язык python прост в изучении, хорошо документирован и очень популярен. Ответы на большинство вопросов касающихся python могут быть найдены с помощью поисковых запросов в вашей любимой поисковой системе.

Этот раздел представляет собой набор примеров, которые показывают основные средства языка python.

<!-- В отличие от C++, python является:

* интерпретируемым языком программирования
* языком со строгой динамической типизацией (в C++ - нестрогая статическая) -->

## Основные типы данных

Встроенные типы являются сильной стороной языка python. Они очень удобны в использовании и предоставляют множество встроенных методов.

### Арифметические типы

В python есть три арифметических типа: `int`, `float` и `complex`:

```py
a = 4
type(a)  # int
b = 4.
type(b)  # float
c = 5 + 6 * (2**5) / 7  # float 32.42857142857143
d = 5 + 6 * (2**5) // 7  # int 32
e = 2 + 3j
type(e)  # complex
type(e.real)  # float
e.conjugate()  # (2-3j)
```

Тип `int` обладает произвольной точностью:

```py
print(2**256)
# 115792089237316195423570985008687907853269984665640564039457584007913129639936
```

Тип `float` на большинстве платформ имеет размер 64 бита.

### Логический тип и объект None

Логический тип `bool` представлен значениями `True` и `False`. Логические выражение можно составлять с помощью операторов `and`, `or` и `not`:

```py
True or False  # True
2 < 3 and 3 < 5  # True
2 < 3 and not 5 < 3  # True
2 == 2  # True
3 != 2  # True
a = True
a is True  # True
```

В последнем примере использован оператор `is`, который проверяет *идентичность* объектов, т.е. ссылаются ли объекты на одну и ту же область памяти. Оператор `is` не проверяет равенство:

```py
a = 3.1415
b = 3.1415
a == b  # True
a is b  # False
```

Объект `None` обозначает отсутствие значения и может использоваться в логических выражениях:

```py
None == None  # True
None is None  # True
not None  # True
bool(None)  # False
```

### Строки

Строки в python представлены типом `str`

```py
s = 'Hello'
type(s)  # str
```

Длину строки можно получить с помощью встроенной функции `len`

```py
len(s)  # 5
```

Конкатенация строк выполняется с помощью оператора сложения

```py
'Hello, ' + 'world!'
```

Тип `str` имеет [большое количество встроенных методов](https://docs.python.org/3/library/stdtypes.html#str). Вот некоторые примеры:

```py
'Hello'.beginswith('Hel')  # True
'Hello'.endswith('llo')  # True
'123'.isdigit()  # True
'123.12'.isdigit()  # False
'abs1'.isalpha()  # False
'abs'.isalpha()  # True
'    123   '.strip()  # '123'
'   123  456   789    '.strip().split()  # ['123', '456', '789']
'/'.join(['/home', 'vitaly', 'python_lecture.ipynb'])  # /home/vitaly/python_lecture.ipynb
```

Выполнить поиск по строке можно с помощью оператора `in` и метода `find`:

```py
'll' in 'Hello'  # True
'Hello'.find('ll')  # 2
```

Со строкой можно работать как с массивом символов символов. Обращение по индексу и выбор диапазона элементов массива в python выполняется весьма удобно:

```py
a = 'apple'
a[1]  # 'p'
a[0:3]  # 'app'
a[:3]  # 'app'
a[-1]  # 'e'
a[-3:]  # 'ple'
sorted(a)  # ['a', 'e', 'l', 'p', 'p']
```

В последнем примере мы воспользовались встроенной функцией `sorted` и получили отсортированный массив символов.

Преобразование строки в арифметические типы выполняется очевидным образом:

```py
int('123')
float('123.45')
complex('123 + 45j')
```

## Встроенные контейнеры

Язык python содержит четыре встроенных контейнера:

* `list` - список
* `tuple` - кортеж
* `set` - множество
* `dict` - словарь

Все эти типы весьма удобны в использовании. Рассмотрим примеры работы с каждым из них.

### Тип list

Создадим list:

```py
l1 = [1, 2, 3]
l2 = [1, '2', 3+4j]
```

Второй пример показывает, что в одном объекте list могут храниться объекты различных типов. Многомерные списки реализуются с помощью вложенных списков. Вот пример двумерного списка (список списков):

```py
l2d = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

Объекты list - изменяемые (в отличие от str и tuple):

```py
lst = []
lst.append(1)  # [1]
lst += [5, 6, 5]  # [1, 5, 6, 5]
lst.remove(5) # [1, 6, 5]
lst
```

Поиск элемента в списке:

```py
l = [43, 55, 98]
55 in l  # True
12 in l  # False
```

Обращение к элементам списка по индексу:

```py
arr = list(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
arr[3]  # 3
arr[-3]  # третий элемент с конца: 7
arr[2:6]  # диапазон элементов со второго по шестой: [2, 3, 4, 5]
arr[:4]  # диапазон элементов от начала до четвертого: [0, 1, 2, 3]
arr[-4:]  # диапазон элементов от четвертого с конца до конца: [6, 7, 8, 9]
arr[1:6:2]  # диапазон элементов от первого до шестоно с шагом 2: [1, 3, 5]
arr[::3]  # каждый третий элемент: [0, 3, 6, 9]
arr[::-3]  # каждый третий элемент, начиная с конца: [9, 6, 3, 0]
arr[::-1]  # все элементы списка в обратном порядке
```

Эти примеры демонстрируют гибкость индексирования в python. После некоторой практики индексирование становится очень простым и удобным инструментом.

Встроенная функция `sorted` позволяет получить копию списка, содержащую отсортированные элементы. Метод `sort` выполняет сортировку исходного списка:

```py
a = [3, 2, 5, 6, 1]
sorted(a)  # [1, 2, 3, 5, 6]
print(a)  # [3, 2, 5, 6, 1]
a.sort()  # сортируем список in place
print(a)  # [1, 2, 3, 5, 6]
```

### Тип tuple

Тип tuple позволяет создавать неизменяемые кортежи объектов:

```py
t = ('Mark', 31, 4.87)
type(t)  # tuple
```

Работать с кортежами можно также как со списками, учитывая, что кортежи неизменяемые. В частности, для них не определен метод `append`. При необходимости изменить кортеж придется создать новый объект.

Кортежи используются в случаях, когда структура данных известна заранее. Часто функции возвращают кортеж объектов.

Неизменяемость кортежей обеспечивает ряд преимуществ по сравнению со списками:

* Кортежи создаются быстрее, чем списки
* Кортежи занимают меньше памяти, чем списки
* Кортежи можно использовать в качестве ключей `set` и `map`, а списки нельзя

### Тип set

Контейнер `set` позволяет работать со множеством уникальных объектов. Контейнер реализован в виде хэш-таблицы и обеспечивает добавление, удаление и поиск элементов за константное время:

```py
s = {1, 5, 2, 3, 5, 4, 1, 'hjk'}
s.add(987)
9 in s  # False
```

Тип `set` поддерживает основные операции со множествами:

```py
a = {1,2,3}
b = {2,3,4}
b-a  # {4}
a & b  # {2, 3}
a | b  # {1, 2, 3, 4}
```

### Тип dict

Контейнер `dict` - это ассоциативный контейнер, который хранит пары ключ-значение. Как и `set`, тип `dict` реализован в виде хэш-таблицы и выполняет операции добавления, поиска и кдаления объектов за константное время:

```py
a = {'key1': 'val1', 'key2': 'val2'}
a['key1']  # 'val1'
a[(1,4)] = 'typle val'  # добавляем новый ключ и новое значение
a['missing_key']  # такого ключа нет, поэтому будет сгенерировано исключение IndexError
a.get('missing_key', None)  # Запросили значение для ключа 'missing_key'. Если ключ не будет найдет, то вернется None
a.update({  # добавляем сразу несколько ключей и значений
    'key3': 'val3,
    'key4': 'val4,
})
'key3' in a  # True
```

### Оператор map и list/set/dict comprehension

## Управляющие конструкции

### Циклы for и while

### Оператор if, тернарный оператор

## Функции

### Встроенные функции

### Лямбда-функции

## intput и print

## Работа с файлами

## Изменяемые и неизменяемые объекты в python

## Типизация в python

## Документация

* [https://www.tutorialspoint.com/python/python_basic_syntax.htm](https://www.tutorialspoint.com/python/python_basic_syntax.htm)
* [https://www.tutorialspoint.com/python/python_variable_types.htm](https://www.tutorialspoint.com/python/python_variable_types.htm)
* [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)
* [Как в Python реализованы очень длинные числа типа integer](https://habr.com/ru/company/otus/blog/489258/)
* [https://www.stavros.io/tutorials/python](https://www.stavros.io/tutorials/python/)
* [https://realpython.com/python-data-types](https://realpython.com/python-data-types/)
* [List Comprehension vs Map (habr)](https://habr.com/ru/post/479252/)